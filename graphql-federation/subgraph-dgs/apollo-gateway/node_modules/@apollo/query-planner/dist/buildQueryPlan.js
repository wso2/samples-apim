"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildQueryPlanningContext = exports.buildOperationContext = exports.collectSubfields = exports.buildQueryPlan = void 0;
const predicates_1 = require("./utilities/predicates");
const graphql_1 = require("graphql");
const FieldSet_1 = require("./FieldSet");
const QueryPlan_1 = require("./QueryPlan");
const graphql_2 = require("./utilities/graphql");
const MultiMap_1 = require("./utilities/MultiMap");
const composedSchema_1 = require("./composedSchema");
const debug_1 = require("./utilities/debug");
const QueryPlanningContext_1 = require("./QueryPlanningContext");
const Scope_1 = require("./Scope");
const deep_equal_1 = __importDefault(require("deep-equal"));
function stringIsTrue(str) {
    if (!str) {
        return false;
    }
    switch (str.toLocaleLowerCase()) {
        case "true":
        case "yes":
        case "1":
            return true;
        default:
            return false;
    }
}
const debug = new debug_1.DebugLogger(stringIsTrue(process.env.APOLLO_QP_DEBUG));
const typenameField = {
    kind: graphql_1.Kind.FIELD,
    name: {
        kind: graphql_1.Kind.NAME,
        value: graphql_1.TypeNameMetaFieldDef.name,
    },
};
function buildQueryPlan(operationContext, options = { autoFragmentization: false }) {
    const context = buildQueryPlanningContext(operationContext, options);
    if (context.operation.operation === 'subscription') {
        throw new graphql_1.GraphQLError('Query planning does not support subscriptions for now.', [context.operation]);
    }
    const rootType = graphql_1.getOperationRootType(context.schema, context.operation);
    const isMutation = context.operation.operation === 'mutation';
    debug.log(() => `Building plan for ${isMutation ? "mutation" : "query"} "${rootType}" (fragments: [${Object.keys(context.fragments)}], autoFragmentization: ${context.autoFragmentization})`);
    debug.group(`Collecting root fields:`);
    const fields = context.collectFields(Scope_1.Scope.create(context, rootType), context.operation.selectionSet);
    debug.groupEnd(`Collected root fields:`);
    debug.groupedValues(fields, FieldSet_1.debugPrintField);
    debug.group('Splitting root fields:');
    const groups = isMutation
        ? splitRootFieldsSerially(context, fields)
        : splitRootFields(context, fields);
    debug.groupEnd('Computed groups:');
    debug.groupedValues(groups, debugPrintGroup);
    const nodes = groups.map(group => executionNodeForGroup(context, group, rootType));
    return {
        kind: 'QueryPlan',
        node: nodes.length
            ? flatWrap(isMutation ? 'Sequence' : 'Parallel', nodes)
            : undefined,
    };
}
exports.buildQueryPlan = buildQueryPlan;
function executionNodeForGroup(context, { serviceName, fields, requiredFields, internalFragments, mergeAt, dependentGroups, }, parentType) {
    const selectionSet = FieldSet_1.selectionSetFromFieldSet(fields, parentType);
    const requires = requiredFields.length > 0
        ? FieldSet_1.selectionSetFromFieldSet(requiredFields)
        : undefined;
    const variableUsages = context.getVariableUsages(selectionSet, internalFragments);
    const operation = requires
        ? operationForEntitiesFetch({
            selectionSet,
            variableUsages,
            internalFragments,
        })
        : operationForRootFetch({
            selectionSet,
            variableUsages,
            internalFragments,
            operation: context.operation.operation,
        });
    const fetchNode = {
        kind: 'Fetch',
        serviceName,
        requires: requires ? QueryPlan_1.trimSelectionNodes(requires === null || requires === void 0 ? void 0 : requires.selections) : undefined,
        variableUsages: Object.keys(variableUsages),
        operation: graphql_1.stripIgnoredCharacters(graphql_1.print(operation)),
    };
    const node = mergeAt && mergeAt.length > 0
        ? {
            kind: 'Flatten',
            path: mergeAt,
            node: fetchNode,
        }
        : fetchNode;
    if (dependentGroups.length > 0) {
        const dependentNodes = dependentGroups.map(dependentGroup => executionNodeForGroup(context, dependentGroup));
        return flatWrap('Sequence', [node, flatWrap('Parallel', dependentNodes)]);
    }
    else {
        return node;
    }
}
function mapFetchNodeToVariableDefinitions(variableUsages) {
    return variableUsages ? Object.values(variableUsages) : [];
}
function operationForRootFetch({ selectionSet, variableUsages, internalFragments, operation = 'query', }) {
    return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [
            {
                kind: graphql_1.Kind.OPERATION_DEFINITION,
                operation,
                selectionSet,
                variableDefinitions: mapFetchNodeToVariableDefinitions(variableUsages),
            },
            ...internalFragments,
        ],
    };
}
function operationForEntitiesFetch({ selectionSet, variableUsages, internalFragments, }) {
    const representationsVariable = {
        kind: graphql_1.Kind.VARIABLE,
        name: { kind: graphql_1.Kind.NAME, value: 'representations' },
    };
    return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [
            {
                kind: graphql_1.Kind.OPERATION_DEFINITION,
                operation: 'query',
                variableDefinitions: [
                    {
                        kind: graphql_1.Kind.VARIABLE_DEFINITION,
                        variable: representationsVariable,
                        type: {
                            kind: graphql_1.Kind.NON_NULL_TYPE,
                            type: {
                                kind: graphql_1.Kind.LIST_TYPE,
                                type: {
                                    kind: graphql_1.Kind.NON_NULL_TYPE,
                                    type: {
                                        kind: graphql_1.Kind.NAMED_TYPE,
                                        name: { kind: graphql_1.Kind.NAME, value: '_Any' },
                                    },
                                },
                            },
                        },
                    },
                ].concat(mapFetchNodeToVariableDefinitions(variableUsages)),
                selectionSet: {
                    kind: graphql_1.Kind.SELECTION_SET,
                    selections: [
                        {
                            kind: graphql_1.Kind.FIELD,
                            name: { kind: graphql_1.Kind.NAME, value: '_entities' },
                            arguments: [
                                {
                                    kind: graphql_1.Kind.ARGUMENT,
                                    name: {
                                        kind: graphql_1.Kind.NAME,
                                        value: representationsVariable.name.value,
                                    },
                                    value: representationsVariable,
                                },
                            ],
                            selectionSet,
                        },
                    ],
                },
            },
            ...internalFragments,
        ],
    };
}
function flatWrap(kind, nodes) {
    if (nodes.length === 0) {
        throw Error('programming error: should always be called with nodes');
    }
    if (nodes.length === 1) {
        return nodes[0];
    }
    return {
        kind,
        nodes: nodes.flatMap(n => (n.kind === kind ? n.nodes : [n])),
    };
}
function splitRootFields(context, fields) {
    const groupsByService = Object.create(null);
    function groupForService(serviceName) {
        let group = groupsByService[serviceName];
        if (!group) {
            group = new FetchGroup(serviceName);
            groupsByService[serviceName] = group;
        }
        return group;
    }
    splitFields(context, [], fields, field => {
        const { scope, fieldNode, fieldDef } = field;
        const { parentType } = scope;
        const owningService = context.getOwningService(parentType, fieldDef);
        if (!owningService) {
            throw new graphql_1.GraphQLError(`Couldn't find owning service for field "${parentType.name}.${fieldDef.name}"`, fieldNode);
        }
        return groupForService(owningService);
    });
    return Object.values(groupsByService);
}
function splitRootFieldsSerially(context, fields) {
    const fetchGroups = [];
    function groupForField(serviceName) {
        let group;
        const previousGroup = fetchGroups[fetchGroups.length - 1];
        if (previousGroup && previousGroup.serviceName === serviceName) {
            return previousGroup;
        }
        group = new FetchGroup(serviceName);
        fetchGroups.push(group);
        return group;
    }
    splitFields(context, [], fields, field => {
        const { scope, fieldNode, fieldDef } = field;
        const { parentType } = scope;
        const owningService = context.getOwningService(parentType, fieldDef);
        if (!owningService) {
            throw new graphql_1.GraphQLError(`Couldn't find owning service for field "${parentType.name}.${fieldDef.name}"`, fieldNode);
        }
        return groupForField(owningService);
    });
    return fetchGroups;
}
function splitSubfields(context, path, fields, parentGroup) {
    splitFields(context, path, fields, field => {
        var _a;
        const { scope, fieldNode, fieldDef } = field;
        const { parentType } = scope;
        let baseService, owningService;
        if (!graphql_1.isObjectType(parentType) || ((_a = composedSchema_1.getFederationMetadataForType(parentType)) === null || _a === void 0 ? void 0 : _a.isValueType)) {
            baseService = parentGroup.serviceName;
            owningService = parentGroup.serviceName;
        }
        else {
            baseService = context.getBaseService(parentType);
            owningService = context.getOwningService(parentType, fieldDef);
        }
        if (!baseService) {
            throw new graphql_1.GraphQLError(`Couldn't find base service for type "${parentType.name}"`, fieldNode);
        }
        if (!owningService) {
            throw new graphql_1.GraphQLError(`Couldn't find owning service for field "${parentType.name}.${fieldDef.name}"`, fieldNode);
        }
        if (owningService === baseService) {
            if (owningService === parentGroup.serviceName ||
                parentGroup.providedFields.some(FieldSet_1.matchesField(field))) {
                return parentGroup;
            }
            else {
                let keyFields = context.getKeyFields(scope, parentGroup.serviceName);
                if (keyFields.length === 0 ||
                    (keyFields.length === 1 &&
                        keyFields[0].fieldDef.name === '__typename')) {
                    keyFields = context.getKeyFields(scope, owningService);
                }
                return parentGroup.dependentGroupForService(owningService, keyFields);
            }
        }
        else {
            const requiredFields = context.getRequiredFields(scope, fieldDef, owningService);
            if (requiredFields.every(requiredField => parentGroup.providedFields.some(FieldSet_1.matchesField(requiredField)))) {
                if (owningService === parentGroup.serviceName) {
                    return parentGroup;
                }
                else {
                    return parentGroup.dependentGroupForService(owningService, requiredFields);
                }
            }
            else {
                const keyFields = context.getKeyFields(scope, parentGroup.serviceName);
                if (!keyFields) {
                    throw new graphql_1.GraphQLError(`Couldn't find keys for type "${parentType.name}}" in service "${baseService}"`, fieldNode);
                }
                if (baseService === parentGroup.serviceName) {
                    return parentGroup.dependentGroupForService(owningService, requiredFields);
                }
                const baseGroup = parentGroup.dependentGroupForService(baseService, keyFields);
                return baseGroup.dependentGroupForService(owningService, requiredFields);
            }
        }
    });
}
function splitFields(context, path, fields, groupForField) {
    for (const fieldsForResponseName of FieldSet_1.groupByResponseName(fields).values()) {
        for (const fieldsForScope of FieldSet_1.groupByScope(fieldsForResponseName).values()) {
            debug.group(() => FieldSet_1.debugPrintFields(fieldsForScope));
            const field = fieldsForScope[0];
            const { scope, fieldDef } = field;
            const parentType = scope.parentType;
            if (fieldDef.name === graphql_1.TypeNameMetaFieldDef.name) {
                const { schema } = context;
                const roots = [
                    schema.getQueryType(),
                    schema.getMutationType(),
                    schema.getSubscriptionType(),
                ]
                    .filter(predicates_1.isNotNullOrUndefined)
                    .map(type => type.name);
                if (roots.indexOf(parentType.name) > -1) {
                    debug.groupEnd("Skipping __typename for root types");
                    continue;
                }
            }
            if (graphql_1.isIntrospectionType(graphql_1.getNamedType(fieldDef.type))) {
                debug.groupEnd(`Skipping introspection type ${fieldDef.type}`);
                continue;
            }
            if (graphql_1.isObjectType(parentType) && scope.possibleRuntimeTypes().includes(parentType)) {
                debug.log(() => `${parentType} = object and ${parentType} ∈ [${scope.possibleRuntimeTypes()}]`);
                const group = groupForField(field);
                debug.log(() => `Initial fetch group for fields: ${debugPrintGroup(group)}`);
                group.fields.push(completeField(context, scope, group, path, fieldsForScope));
                debug.groupEnd(() => `Updated fetch group: ${debugPrintGroup(group)}`);
            }
            else {
                debug.log(() => `${parentType} ≠ object or ${parentType} ∉ [${scope.possibleRuntimeTypes()}]`);
                const possibleFieldDefs = scope.possibleRuntimeTypes().map(runtimeType => context.getFieldDef(runtimeType, field.fieldNode));
                const hasNoExtendingFieldDefs = !possibleFieldDefs.some((field) => { var _a; return (_a = composedSchema_1.getFederationMetadataForField(field)) === null || _a === void 0 ? void 0 : _a.graphName; });
                if (hasNoExtendingFieldDefs) {
                    debug.group(() => `No field of ${scope.possibleRuntimeTypes()} have federation directives, avoid type explosion.`);
                    const group = groupForField(field);
                    debug.groupEnd(() => `Initial fetch group for fields: ${debugPrintGroup(group)}`);
                    group.fields.push(completeField(context, scope, group, path, fieldsForScope));
                    debug.groupEnd(() => `Updated fetch group: ${debugPrintGroup(group)}`);
                    continue;
                }
                const groupsByRuntimeParentTypes = new MultiMap_1.MultiMap();
                debug.group('Computing fetch groups by runtime parent types');
                for (const runtimeParentType of scope.possibleRuntimeTypes()) {
                    const fieldDef = context.getFieldDef(runtimeParentType, field.fieldNode);
                    groupsByRuntimeParentTypes.add(groupForField({
                        scope: scope.refine(runtimeParentType),
                        fieldNode: field.fieldNode,
                        fieldDef,
                    }), runtimeParentType);
                }
                debug.groupEnd(`Fetch groups to resolvable runtime types:`);
                debug.groupedEntries(groupsByRuntimeParentTypes, debugPrintGroup, (v) => v.toString());
                debug.group('Iterating on fetch groups');
                for (const [group, runtimeParentTypes] of groupsByRuntimeParentTypes) {
                    debug.group(() => `For initial fetch group ${debugPrintGroup(group)}:`);
                    for (const runtimeParentType of runtimeParentTypes) {
                        debug.group(`For runtime parent type ${runtimeParentType}:`);
                        const fieldDef = context.getFieldDef(runtimeParentType, field.fieldNode);
                        const fieldsWithRuntimeParentType = fieldsForScope.map(field => ({
                            ...field,
                            fieldDef,
                        }));
                        group.fields.push(completeField(context, scope.refine(runtimeParentType), group, path, fieldsWithRuntimeParentType));
                        debug.groupEnd(() => `Updated fetch group: ${debugPrintGroup(group)}`);
                    }
                    debug.groupEnd();
                }
                debug.groupEnd();
                debug.groupEnd();
            }
        }
    }
}
function completeField(context, scope, parentGroup, path, fields) {
    const { fieldNode, fieldDef } = fields[0];
    const returnType = graphql_1.getNamedType(fieldDef.type);
    if (!graphql_1.isCompositeType(returnType)) {
        return { scope, fieldNode, fieldDef };
    }
    else {
        const fieldPath = addPath(path, graphql_2.getResponseName(fieldNode), fieldDef.type);
        const subGroup = new FetchGroup(parentGroup.serviceName);
        subGroup.mergeAt = fieldPath;
        subGroup.providedFields = context.getProvidedFields(fieldDef, parentGroup.serviceName);
        if (graphql_1.isAbstractType(returnType)) {
            subGroup.fields.push({
                scope: Scope_1.Scope.create(context, returnType),
                fieldNode: typenameField,
                fieldDef: graphql_1.TypeNameMetaFieldDef,
            });
        }
        const subfields = collectSubfields(context, returnType, fields);
        debug.group(() => `Splitting collected sub-fields (${FieldSet_1.debugPrintFields(subfields)})`);
        splitSubfields(context, fieldPath, subfields, subGroup);
        debug.groupEnd();
        parentGroup.mergeDependentGroups(subGroup);
        let definition;
        let selectionSet = FieldSet_1.selectionSetFromFieldSet(subGroup.fields, returnType);
        if (context.autoFragmentization && subGroup.fields.length > 2) {
            ({ definition, selectionSet } = getInternalFragment(selectionSet, returnType, context));
            parentGroup.internalFragments.add(definition);
        }
        subGroup.internalFragments.forEach(fragment => {
            parentGroup.internalFragments.add(fragment);
        });
        return {
            scope,
            fieldNode: {
                ...fieldNode,
                selectionSet,
            },
            fieldDef,
        };
    }
}
function getInternalFragment(selectionSet, returnType, context) {
    const key = JSON.stringify(selectionSet);
    if (!context.internalFragments.has(key)) {
        const name = `__QueryPlanFragment_${context.internalFragmentCount++}__`;
        const definition = {
            kind: graphql_1.Kind.FRAGMENT_DEFINITION,
            name: {
                kind: graphql_1.Kind.NAME,
                value: name,
            },
            typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: returnType.name,
                },
            },
            selectionSet,
        };
        const fragmentSelection = {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
                {
                    kind: graphql_1.Kind.FRAGMENT_SPREAD,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: name,
                    },
                },
            ],
        };
        context.internalFragments.set(key, {
            name,
            definition,
            selectionSet: fragmentSelection,
        });
    }
    return context.internalFragments.get(key);
}
function collectSubfields(context, returnType, fields) {
    let subfields = [];
    for (const field of fields) {
        const selectionSet = field.fieldNode.selectionSet;
        if (selectionSet) {
            subfields = context.collectFields(Scope_1.Scope.create(context, returnType), selectionSet, subfields);
        }
    }
    return subfields;
}
exports.collectSubfields = collectSubfields;
class FetchGroup {
    constructor(serviceName, fields = [], internalFragments = new Set()) {
        this.serviceName = serviceName;
        this.fields = fields;
        this.internalFragments = internalFragments;
        this.requiredFields = [];
        this.providedFields = [];
        this.dependentGroupsByService = Object.create(null);
        this.otherDependentGroups = [];
    }
    dependentGroupForService(serviceName, requiredFields) {
        let group = this.dependentGroupsByService[serviceName];
        if (!group) {
            group = new FetchGroup(serviceName);
            group.mergeAt = this.mergeAt;
            this.dependentGroupsByService[serviceName] = group;
        }
        if (requiredFields) {
            if (group.requiredFields) {
                group.requiredFields.push(...requiredFields);
            }
            else {
                group.requiredFields = requiredFields;
            }
            this.fields.push(...requiredFields);
        }
        return group;
    }
    get dependentGroups() {
        return [
            ...Object.values(this.dependentGroupsByService),
            ...this.otherDependentGroups,
        ];
    }
    mergeDependentGroups(that) {
        for (const dependentGroup of that.dependentGroups) {
            const existingDependentGroup = this.dependentGroups.find((group) => group.serviceName === dependentGroup.serviceName &&
                deep_equal_1.default(group.mergeAt, dependentGroup.mergeAt));
            if (existingDependentGroup) {
                existingDependentGroup.merge(dependentGroup);
            }
            else {
                this.otherDependentGroups.push(dependentGroup);
            }
        }
    }
    merge(otherGroup) {
        this.fields.push(...otherGroup.fields);
        this.requiredFields.push(...otherGroup.requiredFields);
        this.providedFields.push(...otherGroup.providedFields);
        this.mergeDependentGroups(otherGroup);
    }
}
function debugPrintGroup(group) {
    let str = `Fetch(${group.serviceName}, ${FieldSet_1.debugPrintFields(group.fields)}`;
    if (group.dependentGroups.length !== 0) {
        str += `, deps: ${debugPrintGroups(group.dependentGroups)}`;
    }
    return str + ')';
}
function debugPrintGroups(groups) {
    return '[' + groups.map(debugPrintGroup).join(', ') + ']';
}
function buildOperationContext(schema, document, operationName) {
    let operation;
    const fragments = Object.create(null);
    document.definitions.forEach(definition => {
        switch (definition.kind) {
            case graphql_1.Kind.OPERATION_DEFINITION:
                if (!operationName && operation) {
                    throw new graphql_1.GraphQLError('Must provide operation name if query contains ' +
                        'multiple operations.');
                }
                if (!operationName ||
                    (definition.name && definition.name.value === operationName)) {
                    operation = definition;
                }
                break;
            case graphql_1.Kind.FRAGMENT_DEFINITION:
                fragments[definition.name.value] = definition;
                break;
        }
    });
    if (!operation) {
        if (operationName) {
            throw new graphql_1.GraphQLError(`Unknown operation named "${operationName}".`);
        }
        else {
            throw new graphql_1.GraphQLError('Must provide an operation.');
        }
    }
    return { schema, operation, fragments };
}
exports.buildOperationContext = buildOperationContext;
function buildQueryPlanningContext({ operation, schema, fragments }, options) {
    return new QueryPlanningContext_1.QueryPlanningContext(schema, operation, fragments, options.autoFragmentization);
}
exports.buildQueryPlanningContext = buildQueryPlanningContext;
function addPath(path, responseName, type) {
    path = [...path, responseName];
    while (!graphql_1.isNamedType(type)) {
        if (graphql_1.isListType(type)) {
            path.push('@');
        }
        type = type.ofType;
    }
    return path;
}
//# sourceMappingURL=buildQueryPlan.js.map