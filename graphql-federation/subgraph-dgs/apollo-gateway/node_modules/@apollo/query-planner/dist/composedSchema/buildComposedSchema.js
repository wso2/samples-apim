"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComposedSchema = exports.supportedFeatures = void 0;
const graphql_1 = require("graphql");
const assert_1 = require("../utilities/assert");
const graphql_2 = require("../utilities/graphql");
const MultiMap_1 = require("../utilities/MultiMap");
const core_1 = require("./core");
const metadata_1 = require("./metadata");
exports.supportedFeatures = [
    'https://specs.apollo.dev/core/v0.1',
    'https://specs.apollo.dev/join/v0.1',
    'https://specs.apollo.dev/inaccessible/v0.1',
    'https://specs.apollo.dev/tag/v0.1'
].map(core_1.parseFeatureURL);
function buildComposedSchema(document) {
    const schema = graphql_1.buildASTSchema(document);
    const coreName = 'core';
    const coreDirective = schema.getDirective(coreName);
    assert_1.assert(coreDirective, `Expected core schema, but can't find @core directive`);
    const coreDirectivesArgs = graphql_2.getArgumentValuesForRepeatableDirective(coreDirective, schema.astNode);
    for (const coreDirectiveArgs of coreDirectivesArgs) {
        const feature = core_1.parseFeatureURL(coreDirectiveArgs['feature']);
        if (!exports.supportedFeatures.some((supportedFeature) => supportedFeature.identity === feature.identity &&
            supportedFeature.version === feature.version)) {
            throw new graphql_1.GraphQLError(`Unsupported core schema feature and/or version: ${feature}`, schema.astNode);
        }
    }
    const joinName = 'join';
    function getJoinDirective(name) {
        const fullyQualifiedName = `${joinName}__${name}`;
        const directive = schema.getDirective(fullyQualifiedName);
        assert_1.assert(directive, `Composed schema should define @${fullyQualifiedName} directive`);
        return directive;
    }
    const ownerDirective = getJoinDirective('owner');
    const typeDirective = getJoinDirective('type');
    const fieldDirective = getJoinDirective('field');
    const graphDirective = getJoinDirective('graph');
    const graphEnumType = schema.getType(`${joinName}__Graph`);
    assert_1.assert(graphql_1.isEnumType(graphEnumType), `${joinName}__Graph should be an enum`);
    const graphMap = new Map();
    schema.extensions = {
        ...schema.extensions,
        federation: {
            graphs: graphMap,
        },
    };
    for (const graphValue of graphEnumType.getValues()) {
        const name = graphValue.name;
        const graphDirectiveArgs = graphql_2.getArgumentValuesForDirective(graphDirective, graphValue.astNode);
        assert_1.assert(graphDirectiveArgs, `${graphEnumType.name} value ${name} in composed schema should have a @${graphDirective.name} directive`);
        const graphName = graphDirectiveArgs['name'];
        const url = graphDirectiveArgs['url'];
        graphMap.set(name, {
            name: graphName,
            url,
        });
    }
    for (const type of Object.values(schema.getTypeMap())) {
        if (graphql_1.isIntrospectionType(type))
            continue;
        if (!graphql_1.isObjectType(type))
            continue;
        assert_1.assert(type.astNode, `GraphQL type "${type.name}" should contain AST nodes`);
        const ownerDirectiveArgs = graphql_2.getArgumentValuesForDirective(ownerDirective, type.astNode);
        let typeMetadata;
        if (ownerDirectiveArgs) {
            assert_1.assert(ownerDirectiveArgs.graph, `@${ownerDirective.name} directive requires a \`graph\` argument`);
            const graph = graphMap.get(ownerDirectiveArgs.graph);
            assertGraphFound(graph, ownerDirectiveArgs.graph, ownerDirective.name);
            typeMetadata = {
                graphName: graph.name,
                keys: new MultiMap_1.MultiMap(),
                isValueType: false,
            };
        }
        else {
            typeMetadata = {
                isValueType: true,
            };
        }
        type.extensions = {
            ...type.extensions,
            federation: typeMetadata,
        };
        const typeDirectivesArgs = graphql_2.getArgumentValuesForRepeatableDirective(typeDirective, type.astNode);
        assert_1.assert(metadata_1.isEntityTypeMetadata(typeMetadata) || typeDirectivesArgs.length === 0, `GraphQL type "${type.name}" cannot have a @${typeDirective.name} \
directive without an @${ownerDirective.name} directive`);
        for (const typeDirectiveArgs of typeDirectivesArgs) {
            assert_1.assert(typeDirectiveArgs.graph, `GraphQL type "${type.name}" must provide a \`graph\` argument to the @${typeDirective.name} directive`);
            const graph = graphMap.get(typeDirectiveArgs.graph);
            assertGraphFound(graph, typeDirectiveArgs.graph, typeDirective.name);
            const keyFields = graphql_2.parseFieldSet(typeDirectiveArgs['key']);
            typeMetadata.keys.add(graph.name, keyFields);
        }
        for (const fieldDef of Object.values(type.getFields())) {
            assert_1.assert(fieldDef.astNode, `Field "${type.name}.${fieldDef.name}" should contain AST nodes`);
            const fieldDirectiveArgs = graphql_2.getArgumentValuesForDirective(fieldDirective, fieldDef.astNode);
            if (!fieldDirectiveArgs)
                continue;
            let fieldMetadata;
            if (fieldDirectiveArgs.graph) {
                const graph = graphMap.get(fieldDirectiveArgs.graph);
                assertGraphFound(graph, fieldDirectiveArgs.graph, fieldDirective.name);
                fieldMetadata = { graphName: graph.name };
            }
            else {
                fieldMetadata = { graphName: undefined };
            }
            fieldDef.extensions = {
                ...fieldDef.extensions,
                federation: fieldMetadata,
            };
            const { requires, provides } = fieldDirectiveArgs;
            if (requires) {
                fieldMetadata.requires = graphql_2.parseFieldSet(requires);
            }
            if (provides) {
                fieldMetadata.provides = graphql_2.parseFieldSet(provides);
            }
        }
    }
    return schema;
}
exports.buildComposedSchema = buildComposedSchema;
function assertGraphFound(graph, graphName, directiveName) {
    assert_1.assert(graph, `Programming error: found unexpected \`graph\` argument value "${graphName}" in @${directiveName} directive`);
}
//# sourceMappingURL=buildComposedSchema.js.map