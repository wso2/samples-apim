"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeInaccessibleElements = void 0;
const graphql_1 = require("graphql");
const apollo_graphql_1 = require("apollo-graphql");
function removeInaccessibleElements(schema) {
    const inaccessibleDirective = schema.getDirective('inaccessible');
    if (!inaccessibleDirective)
        return schema;
    const typesToRemove = new Set(Object.values(schema.getTypeMap()).filter((type) => {
        if (!type.astNode)
            return false;
        return hasDirective(inaccessibleDirective, type.astNode);
    }));
    removeRootTypesIfNeeded();
    return apollo_graphql_1.transformSchema(schema, (type) => {
        if (typesToRemove.has(type))
            return null;
        if (graphql_1.isObjectType(type)) {
            const typeConfig = type.toConfig();
            return new graphql_1.GraphQLObjectType({
                ...typeConfig,
                fields: removeInaccessibleFields(type, typeConfig.fields),
                interfaces: removeInaccessibleTypes(typeConfig.interfaces),
            });
        }
        else if (graphql_1.isInterfaceType(type)) {
            const typeConfig = type.toConfig();
            return new graphql_1.GraphQLInterfaceType({
                ...typeConfig,
                fields: removeInaccessibleFields(type, typeConfig.fields),
                interfaces: removeInaccessibleTypes(typeConfig.interfaces),
            });
        }
        else if (graphql_1.isUnionType(type)) {
            const typeConfig = type.toConfig();
            return new graphql_1.GraphQLUnionType({
                ...typeConfig,
                types: removeInaccessibleTypes(typeConfig.types),
            });
        }
        else {
            return undefined;
        }
    });
    function removeRootTypesIfNeeded() {
        let schemaConfig = schema.toConfig();
        let hasRemovedRootType = false;
        const queryType = schema.getQueryType();
        if (queryType && typesToRemove.has(queryType)) {
            schemaConfig.query = undefined;
            hasRemovedRootType = true;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && typesToRemove.has(mutationType)) {
            schemaConfig.mutation = undefined;
            hasRemovedRootType = true;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && typesToRemove.has(subscriptionType)) {
            schemaConfig.subscription = undefined;
            hasRemovedRootType = true;
        }
        if (hasRemovedRootType) {
            schema = new graphql_1.GraphQLSchema(schemaConfig);
        }
    }
    function removeInaccessibleFields(type, fieldMapConfig) {
        const newFieldMapConfig = Object.create(null);
        for (const [fieldName, fieldConfig] of Object.entries(fieldMapConfig)) {
            if (fieldConfig.astNode &&
                hasDirective(inaccessibleDirective, fieldConfig.astNode)) {
                continue;
            }
            else if (typesToRemove.has(graphql_1.getNamedType(fieldConfig.type))) {
                throw new graphql_1.GraphQLError(`Field ${type.name}.${fieldName} returns ` +
                    `an @inaccessible type without being marked @inaccessible itself.`, fieldConfig.astNode);
            }
            newFieldMapConfig[fieldName] = fieldConfig;
        }
        return newFieldMapConfig;
    }
    function removeInaccessibleTypes(types) {
        return types.filter((type) => !typesToRemove.has(type));
    }
}
exports.removeInaccessibleElements = removeInaccessibleElements;
function hasDirective(directiveDef, node) {
    if (!node.directives)
        return false;
    return node.directives.some((directiveNode) => directiveNode.name.value === directiveDef.name);
}
//# sourceMappingURL=removeInaccessibleElements.js.map