"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isASTKind = exports.getArgumentValuesForRepeatableDirective = exports.getArgumentValuesForDirective = exports.parseFieldSet = exports.parseSelections = exports.astFromType = exports.allNodesAreOfSameKind = exports.getResponseName = exports.getFieldDef = void 0;
const graphql_1 = require("graphql");
const values_1 = require("graphql/execution/values");
const assert_1 = require("./assert");
function getFieldDef(schema, parentType, fieldName) {
    if (fieldName === graphql_1.SchemaMetaFieldDef.name &&
        schema.getQueryType() === parentType) {
        return graphql_1.SchemaMetaFieldDef;
    }
    if (fieldName === graphql_1.TypeMetaFieldDef.name &&
        schema.getQueryType() === parentType) {
        return graphql_1.TypeMetaFieldDef;
    }
    if (fieldName === graphql_1.TypeNameMetaFieldDef.name &&
        (parentType instanceof graphql_1.GraphQLObjectType ||
            parentType instanceof graphql_1.GraphQLInterfaceType ||
            parentType instanceof graphql_1.GraphQLUnionType)) {
        return graphql_1.TypeNameMetaFieldDef;
    }
    if (parentType instanceof graphql_1.GraphQLObjectType ||
        parentType instanceof graphql_1.GraphQLInterfaceType) {
        return parentType.getFields()[fieldName];
    }
    return undefined;
}
exports.getFieldDef = getFieldDef;
function getResponseName(node) {
    return node.alias ? node.alias.value : node.name.value;
}
exports.getResponseName = getResponseName;
function allNodesAreOfSameKind(firstNode, remainingNodes) {
    return !remainingNodes.some(node => node.kind !== firstNode.kind);
}
exports.allNodesAreOfSameKind = allNodesAreOfSameKind;
function astFromType(type) {
    if (graphql_1.isListType(type)) {
        return { kind: graphql_1.Kind.LIST_TYPE, type: astFromType(type.ofType) };
    }
    else if (graphql_1.isNonNullType(type)) {
        return { kind: graphql_1.Kind.NON_NULL_TYPE, type: astFromType(type.ofType) };
    }
    else {
        return {
            kind: graphql_1.Kind.NAMED_TYPE,
            name: { kind: graphql_1.Kind.NAME, value: type.name },
        };
    }
}
exports.astFromType = astFromType;
function parseSelections(source) {
    const parsed = graphql_1.parse(`{${source}}`);
    assert_1.assert(parsed.definitions.length === 1, `Invalid FieldSet provided: '${source}'. FieldSets may not contain operations within them.`);
    return parsed.definitions[0].selectionSet
        .selections;
}
exports.parseSelections = parseSelections;
function parseFieldSet(source) {
    const selections = parseSelections(source);
    const selectionSetNode = {
        kind: graphql_1.Kind.SELECTION_SET,
        selections,
    };
    graphql_1.visit(selectionSetNode, {
        FragmentSpread() {
            throw Error(`Field sets may not contain fragment spreads, but found: "${source}"`);
        },
    });
    assert_1.assert(selections.length > 0, `Field sets may not be empty`);
    return selections;
}
exports.parseFieldSet = parseFieldSet;
function getArgumentValuesForDirective(directiveDef, node) {
    assert_1.assert(!directiveDef.isRepeatable, 'Use getArgumentValuesForRepeatableDirective for repeatable directives');
    if (!node.directives)
        return undefined;
    const directiveNode = node.directives.find((directiveNode) => directiveNode.name.value === directiveDef.name);
    if (!directiveNode)
        return undefined;
    return values_1.getArgumentValues(directiveDef, directiveNode);
}
exports.getArgumentValuesForDirective = getArgumentValuesForDirective;
function getArgumentValuesForRepeatableDirective(directiveDef, node) {
    if (!node.directives)
        return [];
    const directiveNodes = node.directives.filter((directiveNode) => directiveNode.name.value === directiveDef.name);
    return directiveNodes.map((directiveNode) => values_1.getArgumentValues(directiveDef, directiveNode));
}
exports.getArgumentValuesForRepeatableDirective = getArgumentValuesForRepeatableDirective;
function isASTKind(...kinds) {
    return (node) => kinds.some((kind) => node.kind === kind);
}
exports.isASTKind = isASTKind;
//# sourceMappingURL=graphql.js.map