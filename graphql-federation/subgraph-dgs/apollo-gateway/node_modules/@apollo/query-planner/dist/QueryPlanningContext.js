"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryPlanningContext = void 0;
const graphql_1 = require("graphql");
const composedSchema_1 = require("./composedSchema");
const Scope_1 = require("./Scope");
const graphql_2 = require("./utilities/graphql");
const typenameField = {
    kind: graphql_1.Kind.FIELD,
    name: {
        kind: graphql_1.Kind.NAME,
        value: graphql_1.TypeNameMetaFieldDef.name,
    },
};
class QueryPlanningContext {
    constructor(schema, operation, fragments, autoFragmentization) {
        this.schema = schema;
        this.operation = operation;
        this.fragments = fragments;
        this.autoFragmentization = autoFragmentization;
        this.internalFragments = new Map();
        this.internalFragmentCount = 0;
        this.variableDefinitions = Object.create(null);
        graphql_1.visit(operation, {
            VariableDefinition: definition => {
                this.variableDefinitions[definition.variable.name.value] = definition;
            },
        });
    }
    getFieldDef(parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        const fieldDef = graphql_2.getFieldDef(this.schema, parentType, fieldName);
        if (!fieldDef) {
            throw new graphql_1.GraphQLError(`Cannot query field "${fieldNode.name.value}" on type "${String(parentType)}"`, fieldNode);
        }
        return fieldDef;
    }
    getPossibleTypes(type) {
        return graphql_1.isAbstractType(type) ? this.schema.getPossibleTypes(type) : [type];
    }
    getVariableUsages(selectionSet, fragments) {
        const usages = Object.create(null);
        const document = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [
                { kind: graphql_1.Kind.OPERATION_DEFINITION, selectionSet, operation: 'query' },
                ...Array.from(fragments),
            ],
        };
        graphql_1.visit(document, {
            Variable: (node) => {
                usages[node.name.value] = this.variableDefinitions[node.name.value];
            },
        });
        return usages;
    }
    getBaseService(parentType) {
        const type = composedSchema_1.getFederationMetadataForType(parentType);
        return (type && composedSchema_1.isEntityTypeMetadata(type)) ? type.graphName : undefined;
    }
    getOwningService(parentType, fieldDef) {
        var _a, _b;
        return ((_b = (_a = composedSchema_1.getFederationMetadataForField(fieldDef)) === null || _a === void 0 ? void 0 : _a.graphName) !== null && _b !== void 0 ? _b : this.getBaseService(parentType));
    }
    getKeyFields(scope, serviceName, fetchAll = false) {
        const keyFields = [];
        keyFields.push({
            scope: scope,
            fieldNode: typenameField,
            fieldDef: graphql_1.TypeNameMetaFieldDef,
        });
        for (const possibleType of scope.possibleRuntimeTypes()) {
            const type = composedSchema_1.getFederationMetadataForType(possibleType);
            const keys = type && composedSchema_1.isEntityTypeMetadata(type)
                ? type.keys.get(serviceName)
                : undefined;
            if (!(keys && keys.length > 0))
                continue;
            if (fetchAll) {
                keyFields.push(...keys.flatMap(key => this.collectFields(scope.refine(possibleType), {
                    kind: graphql_1.Kind.SELECTION_SET,
                    selections: key,
                })));
            }
            else {
                keyFields.push(...this.collectFields(scope.refine(possibleType), {
                    kind: graphql_1.Kind.SELECTION_SET,
                    selections: keys[0],
                }));
            }
        }
        return keyFields;
    }
    getRequiredFields(scope, fieldDef, serviceName) {
        const requiredFields = [];
        requiredFields.push(...this.getKeyFields(scope, serviceName));
        const fieldFederationMetadata = composedSchema_1.getFederationMetadataForField(fieldDef);
        if (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.requires) {
            requiredFields.push(...this.collectFields(scope, {
                kind: graphql_1.Kind.SELECTION_SET,
                selections: fieldFederationMetadata.requires,
            }));
        }
        return requiredFields;
    }
    getProvidedFields(fieldDef, serviceName) {
        const returnType = graphql_1.getNamedType(fieldDef.type);
        if (!graphql_1.isCompositeType(returnType))
            return [];
        const providedFields = [];
        providedFields.push(...this.getKeyFields(Scope_1.Scope.create(this, returnType), serviceName, true));
        const fieldFederationMetadata = composedSchema_1.getFederationMetadataForField(fieldDef);
        if (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.provides) {
            providedFields.push(...this.collectFields(Scope_1.Scope.create(this, returnType), {
                kind: graphql_1.Kind.SELECTION_SET,
                selections: fieldFederationMetadata.provides,
            }));
        }
        return providedFields;
    }
    getFragmentCondition(parentType, fragment) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode)
            return parentType;
        return graphql_1.typeFromAST(this.schema, typeConditionNode);
    }
    scopeForFragment(currentScope, fragment, appliedDirectives) {
        const condition = this.getFragmentCondition(currentScope.parentType, fragment);
        const newScope = currentScope.refine(condition, appliedDirectives);
        return (newScope.possibleRuntimeTypes().length == 0) ? undefined : newScope;
    }
    collectFields(scope, selectionSet, fields = []) {
        for (const selection of selectionSet.selections) {
            switch (selection.kind) {
                case graphql_1.Kind.FIELD:
                    const fieldDef = this.getFieldDef(scope.parentType, selection);
                    fields.push({ scope, fieldNode: selection, fieldDef });
                    break;
                case graphql_1.Kind.INLINE_FRAGMENT: {
                    const newScope = this.scopeForFragment(scope, selection, selection.directives);
                    if (newScope) {
                        this.collectFields(newScope, selection.selectionSet, fields);
                    }
                    break;
                }
                case graphql_1.Kind.FRAGMENT_SPREAD:
                    const fragmentName = selection.name.value;
                    const fragment = this.fragments[fragmentName];
                    if (!fragment) {
                        continue;
                    }
                    const newScope = this.scopeForFragment(scope, fragment, selection.directives);
                    if (newScope) {
                        this.collectFields(newScope, fragment.selectionSet, fields);
                    }
                    break;
            }
        }
        return fields;
    }
}
exports.QueryPlanningContext = QueryPlanningContext;
//# sourceMappingURL=QueryPlanningContext.js.map