"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildOperationContext = exports.executeQueryPlan = exports.ApolloGateway = exports.SERVICE_DEFINITION_QUERY = exports.HEALTH_CHECK_QUERY = exports.GCS_RETRY_COUNT = exports.getDefaultGcsFetcher = exports.getDefaultFetcher = void 0;
const apollo_server_caching_1 = require("apollo-server-caching");
const graphql_1 = require("graphql");
const federation_1 = require("@apollo/federation");
const loglevel_1 = __importDefault(require("loglevel"));
const operationContext_1 = require("./operationContext");
Object.defineProperty(exports, "buildOperationContext", { enumerable: true, get: function () { return operationContext_1.buildOperationContext; } });
const executeQueryPlan_1 = require("./executeQueryPlan");
Object.defineProperty(exports, "executeQueryPlan", { enumerable: true, get: function () { return executeQueryPlan_1.executeQueryPlan; } });
const loadServicesFromRemoteEndpoint_1 = require("./loadServicesFromRemoteEndpoint");
const types_1 = require("./datasources/types");
const RemoteGraphQLDataSource_1 = require("./datasources/RemoteGraphQLDataSource");
const values_1 = require("graphql/execution/values");
const make_fetch_happen_1 = __importDefault(require("make-fetch-happen"));
const cache_1 = require("./cache");
const query_planner_1 = require("@apollo/query-planner");
const config_1 = require("./config");
const loadSupergraphSdlFromStorage_1 = require("./loadSupergraphSdlFromStorage");
const legacyLoadServicesFromStorage_1 = require("./legacyLoadServicesFromStorage");
const query_planner_2 = require("@apollo/query-planner");
const api_1 = require("@opentelemetry/api");
const opentelemetry_1 = require("./utilities/opentelemetry");
function getDefaultFetcher() {
    const { name, version } = require('../package.json');
    return make_fetch_happen_1.default.defaults({
        cacheManager: new cache_1.HttpRequestCache(),
        headers: {
            'apollographql-client-name': name,
            'apollographql-client-version': version,
            'user-agent': `${name}/${version}`,
            'content-type': 'application/json',
        },
        retry: {
            retries: 5,
            factor: 2,
            minTimeout: 1000,
            randomize: true,
        },
    });
}
exports.getDefaultFetcher = getDefaultFetcher;
exports.getDefaultGcsFetcher = getDefaultFetcher;
exports.GCS_RETRY_COUNT = 5;
exports.HEALTH_CHECK_QUERY = 'query __ApolloServiceHealthCheck__ { __typename }';
exports.SERVICE_DEFINITION_QUERY = 'query __ApolloGetServiceDefinition__ { _service { sdl } }';
class ApolloGateway {
    constructor(config) {
        var _a, _b;
        this.serviceMap = Object.create(null);
        this.onSchemaChangeListeners = new Set();
        this.onSchemaLoadOrUpdateListeners = new Set();
        this.serviceDefinitions = [];
        this.serviceSdlCache = new Map();
        this.warnedStates = Object.create(null);
        this.executor = async (requestContext) => {
            const spanAttributes = requestContext.operationName
                ? { operationName: requestContext.operationName }
                : {};
            return opentelemetry_1.tracer.startActiveSpan(opentelemetry_1.OpenTelemetrySpanNames.REQUEST, { attributes: spanAttributes }, async (span) => {
                try {
                    const { request, document, queryHash } = requestContext;
                    const queryPlanStoreKey = queryHash + (request.operationName || '');
                    const operationContext = operationContext_1.buildOperationContext({
                        schema: this.schema,
                        operationDocument: document,
                        operationName: request.operationName,
                    });
                    const validationErrors = this.validateIncomingRequest(requestContext, operationContext);
                    if (validationErrors.length > 0) {
                        span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                        return { errors: validationErrors };
                    }
                    let queryPlan;
                    if (this.queryPlanStore) {
                        queryPlan = await this.queryPlanStore.get(queryPlanStoreKey);
                    }
                    if (!queryPlan) {
                        queryPlan = opentelemetry_1.tracer.startActiveSpan(opentelemetry_1.OpenTelemetrySpanNames.PLAN, (span) => {
                            try {
                                return this.queryPlanner.buildQueryPlan(operationContext, {
                                    autoFragmentization: Boolean(this.config.experimental_autoFragmentization),
                                });
                            }
                            catch (err) {
                                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                                throw err;
                            }
                            finally {
                                span.end();
                            }
                        });
                        if (this.queryPlanStore) {
                            Promise.resolve(this.queryPlanStore.set(queryPlanStoreKey, queryPlan)).catch((err) => this.logger.warn('Could not store queryPlan' + ((err && err.message) || err)));
                        }
                    }
                    const serviceMap = Object.entries(this.serviceMap).reduce((serviceDataSources, [serviceName, { dataSource }]) => {
                        serviceDataSources[serviceName] = dataSource;
                        return serviceDataSources;
                    }, Object.create(null));
                    if (this.experimental_didResolveQueryPlan) {
                        this.experimental_didResolveQueryPlan({
                            queryPlan,
                            serviceMap,
                            requestContext,
                            operationContext,
                        });
                    }
                    const response = await executeQueryPlan_1.executeQueryPlan(queryPlan, serviceMap, requestContext, operationContext);
                    const shouldShowQueryPlan = this.config.__exposeQueryPlanExperimental &&
                        request.http &&
                        request.http.headers &&
                        request.http.headers.get('Apollo-Query-Plan-Experimental');
                    const serializedQueryPlan = queryPlan.node && (this.config.debug || shouldShowQueryPlan)
                        ?
                            query_planner_1.prettyFormatQueryPlan(queryPlan)
                        : null;
                    if (this.config.debug && serializedQueryPlan) {
                        this.logger.debug(serializedQueryPlan);
                    }
                    if (shouldShowQueryPlan) {
                        response.extensions = {
                            __queryPlanExperimental: serializedQueryPlan || true,
                        };
                    }
                    if (response.errors) {
                        span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                    }
                    return response;
                }
                catch (err) {
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                    throw err;
                }
                finally {
                    span.end();
                }
            });
        };
        this.config = {
            __exposeQueryPlanExperimental: process.env.NODE_ENV !== 'production',
            ...config,
        };
        this.logger = this.initLogger();
        this.queryPlanStore = this.initQueryPlanStore(config === null || config === void 0 ? void 0 : config.experimental_approximateQueryPlanStoreMiB);
        this.fetcher = (config === null || config === void 0 ? void 0 : config.fetcher) || getDefaultFetcher();
        this.experimental_didResolveQueryPlan =
            config === null || config === void 0 ? void 0 : config.experimental_didResolveQueryPlan;
        this.experimental_didFailComposition =
            config === null || config === void 0 ? void 0 : config.experimental_didFailComposition;
        this.experimental_didUpdateComposition =
            config === null || config === void 0 ? void 0 : config.experimental_didUpdateComposition;
        this.experimental_pollInterval = config === null || config === void 0 ? void 0 : config.experimental_pollInterval;
        if (config_1.isPrecomposedManagedConfig(this.config)) {
            const envEndpoint = process.env.APOLLO_SCHEMA_CONFIG_DELIVERY_ENDPOINT;
            this.schemaConfigDeliveryEndpoint =
                (_b = (_a = this.config.schemaConfigDeliveryEndpoint) !== null && _a !== void 0 ? _a : envEndpoint) !== null && _b !== void 0 ? _b : 'https://uplink.api.apollographql.com/';
        }
        else if (config_1.isLegacyManagedConfig(this.config)) {
            this.schemaConfigDeliveryEndpoint = null;
        }
        if (config_1.isManuallyManagedConfig(this.config)) {
            if ('experimental_updateSupergraphSdl' in this.config) {
                this.updateServiceDefinitions =
                    this.config.experimental_updateSupergraphSdl;
            }
            else if ('experimental_updateServiceDefinitions' in this.config) {
                this.updateServiceDefinitions =
                    this.config.experimental_updateServiceDefinitions;
            }
            else {
                throw Error('Programming error: unexpected manual configuration provided');
            }
        }
        else {
            this.updateServiceDefinitions = this.loadServiceDefinitions;
        }
        if (config_1.isDynamicConfig(this.config)) {
            this.issueDynamicWarningsIfApplicable();
        }
        this.state = { phase: 'initialized' };
    }
    initLogger() {
        if (this.config.logger) {
            return this.config.logger;
        }
        const loglevelLogger = loglevel_1.default.getLogger(`apollo-gateway`);
        if (this.config.debug === true) {
            loglevelLogger.setLevel(loglevelLogger.levels.DEBUG);
        }
        else {
            loglevelLogger.setLevel(loglevelLogger.levels.WARN);
        }
        return loglevelLogger;
    }
    initQueryPlanStore(approximateQueryPlanStoreMiB) {
        return new apollo_server_caching_1.InMemoryLRUCache({
            maxSize: Math.pow(2, 20) * (approximateQueryPlanStoreMiB || 30),
            sizeCalculator: approximateObjectSize,
        });
    }
    issueDynamicWarningsIfApplicable() {
        if (config_1.isManagedConfig(this.config) &&
            this.config.experimental_pollInterval &&
            this.config.experimental_pollInterval < 10000) {
            this.experimental_pollInterval = 10000;
            this.logger.warn('Polling Apollo services at a frequency of less than once per 10 ' +
                'seconds (10000) is disallowed. Instead, the minimum allowed ' +
                'pollInterval of 10000 will be used. Please reconfigure your ' +
                'experimental_pollInterval accordingly. If this is problematic for ' +
                'your team, please contact support.');
        }
        if (this.config.experimental_pollInterval && config_1.isRemoteConfig(this.config)) {
            this.logger.warn('Polling running services is dangerous and not recommended in production. ' +
                'Polling should only be used against a registry. ' +
                'If you are polling running services, use with caution.');
        }
        if (config_1.isManuallyManagedConfig(this.config) &&
            'experimental_updateSupergraphSdl' in this.config &&
            'experimental_updateServiceDefinitions' in this.config) {
            this.logger.warn('Gateway found two manual update configurations when only one should be ' +
                'provided. Gateway will default to using the provided `experimental_updateSupergraphSdl` ' +
                'function when both `experimental_updateSupergraphSdl` and experimental_updateServiceDefinitions` ' +
                'are provided.');
        }
    }
    async load(options) {
        if (this.state.phase !== 'initialized') {
            throw Error(`ApolloGateway.load called in surprising state ${this.state.phase}`);
        }
        if (options === null || options === void 0 ? void 0 : options.apollo) {
            const { key, keyHash, graphRef, graphId, graphVariant } = options.apollo;
            this.apolloConfig = {
                key,
                keyHash,
                graphRef: graphRef !== null && graphRef !== void 0 ? graphRef : (graphId ? `${graphId}@${graphVariant !== null && graphVariant !== void 0 ? graphVariant : 'current'}` : undefined),
            };
        }
        else if (options === null || options === void 0 ? void 0 : options.engine) {
            const { apiKeyHash, graphId, graphVariant } = options.engine;
            this.apolloConfig = {
                keyHash: apiKeyHash,
                graphRef: graphId
                    ? `${graphId}@${graphVariant !== null && graphVariant !== void 0 ? graphVariant : 'current'}`
                    : undefined,
            };
        }
        const unrefTimer = !!options && !options.apollo;
        this.maybeWarnOnConflictingConfig();
        config_1.isStaticConfig(this.config)
            ? this.loadStatic(this.config)
            : await this.loadDynamic(unrefTimer);
        const mode = config_1.isManagedConfig(this.config) ? 'managed' : 'unmanaged';
        this.logger.info(`Gateway successfully loaded schema.\n\t* Mode: ${mode}${this.apolloConfig && this.apolloConfig.graphRef
            ? `\n\t* Service: ${this.apolloConfig.graphRef}`
            : ''}`);
        return {
            schema: this.schema,
            executor: this.executor,
        };
    }
    loadStatic(config) {
        let schema;
        let supergraphSdl;
        try {
            ({ schema, supergraphSdl } = config_1.isLocalConfig(config)
                ? this.createSchemaFromServiceList(config.localServiceList)
                : this.createSchemaFromSupergraphSdl(config.supergraphSdl));
            this.parsedSupergraphSdl = graphql_1.parse(supergraphSdl);
            this.updateWithSchemaAndNotify(schema, supergraphSdl, true);
        }
        catch (e) {
            this.state = { phase: 'failed to load' };
            throw e;
        }
        this.state = { phase: 'loaded' };
    }
    async loadDynamic(unrefTimer) {
        try {
            await this.updateSchema();
        }
        catch (e) {
            this.state = { phase: 'failed to load' };
            throw e;
        }
        this.state = { phase: 'loaded' };
        if (this.shouldBeginPolling()) {
            this.pollServices(unrefTimer);
        }
    }
    shouldBeginPolling() {
        return config_1.isManagedConfig(this.config) || this.experimental_pollInterval;
    }
    async updateSchema() {
        this.logger.debug('Checking for composition updates...');
        const result = await this.updateServiceDefinitions(this.config);
        if (config_1.isSupergraphSdlUpdate(result)) {
            await this.updateWithSupergraphSdl(result);
        }
        else if (config_1.isServiceDefinitionUpdate(result)) {
            await this.updateByComposition(result);
        }
        else {
            throw new Error('Programming error: unexpected result type from `updateServiceDefinitions`');
        }
    }
    async updateByComposition(result) {
        if (!result.serviceDefinitions ||
            JSON.stringify(this.serviceDefinitions) ===
                JSON.stringify(result.serviceDefinitions)) {
            this.logger.debug('No change in service definitions since last check.');
            return;
        }
        const previousSchema = this.schema;
        const previousServiceDefinitions = this.serviceDefinitions;
        const previousCompositionMetadata = this.compositionMetadata;
        if (previousSchema) {
            this.logger.info('New service definitions were found.');
        }
        await this.maybePerformServiceHealthCheck(result);
        this.compositionMetadata = result.compositionMetadata;
        this.serviceDefinitions = result.serviceDefinitions;
        const { schema, supergraphSdl } = this.createSchemaFromServiceList(result.serviceDefinitions);
        if (!supergraphSdl) {
            this.logger.error("A valid schema couldn't be composed. Falling back to previous schema.");
        }
        else {
            this.updateWithSchemaAndNotify(schema, supergraphSdl);
            if (this.experimental_didUpdateComposition) {
                this.experimental_didUpdateComposition({
                    serviceDefinitions: result.serviceDefinitions,
                    schema,
                    ...(this.compositionMetadata && {
                        compositionMetadata: this.compositionMetadata,
                    }),
                }, previousServiceDefinitions &&
                    previousSchema && {
                    serviceDefinitions: previousServiceDefinitions,
                    schema: previousSchema,
                    ...(previousCompositionMetadata && {
                        compositionMetadata: previousCompositionMetadata,
                    }),
                });
            }
        }
    }
    async updateWithSupergraphSdl(result) {
        if (result.id === this.compositionId) {
            this.logger.debug('No change in composition since last check.');
            return;
        }
        const parsedSupergraphSdl = graphql_1.parse(result.supergraphSdl);
        const previousSchema = this.schema;
        const previousSupergraphSdl = this.parsedSupergraphSdl;
        const previousCompositionId = this.compositionId;
        if (previousSchema) {
            this.logger.info('Updated Supergraph SDL was found.');
        }
        await this.maybePerformServiceHealthCheck(result);
        this.compositionId = result.id;
        this.parsedSupergraphSdl = parsedSupergraphSdl;
        const { schema, supergraphSdl } = this.createSchemaFromSupergraphSdl(result.supergraphSdl);
        if (!supergraphSdl) {
            this.logger.error("A valid schema couldn't be composed. Falling back to previous schema.");
        }
        else {
            this.updateWithSchemaAndNotify(schema, supergraphSdl);
            if (this.experimental_didUpdateComposition) {
                this.experimental_didUpdateComposition({
                    compositionId: result.id,
                    supergraphSdl: result.supergraphSdl,
                    schema,
                }, previousCompositionId && previousSupergraphSdl && previousSchema
                    ? {
                        compositionId: previousCompositionId,
                        supergraphSdl: graphql_1.print(previousSupergraphSdl),
                        schema: previousSchema,
                    }
                    : undefined);
            }
        }
    }
    updateWithSchemaAndNotify(coreSchema, coreSupergraphSdl, legacyDontNotifyOnSchemaChangeListeners = false) {
        if (this.queryPlanStore)
            this.queryPlanStore.flush();
        this.schema = query_planner_1.toAPISchema(coreSchema);
        this.queryPlanner = new query_planner_1.QueryPlanner(coreSchema);
        if (!legacyDontNotifyOnSchemaChangeListeners) {
            this.onSchemaChangeListeners.forEach((listener) => {
                try {
                    listener(this.schema);
                }
                catch (e) {
                    this.logger.error("An error was thrown from an 'onSchemaChange' listener. " +
                        'The schema will still update: ' +
                        ((e && e.message) || e));
                }
            });
        }
        this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
            try {
                listener({
                    apiSchema: this.schema,
                    coreSupergraphSdl,
                });
            }
            catch (e) {
                this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener. " +
                    'The schema will still update: ' +
                    ((e && e.message) || e));
            }
        });
    }
    async maybePerformServiceHealthCheck(update) {
        if (this.config.serviceHealthCheck) {
            const serviceList = config_1.isSupergraphSdlUpdate(update)
                ?
                    this.serviceListFromSupergraphSdl(graphql_1.parse(update.supergraphSdl))
                :
                    update.serviceDefinitions;
            const serviceMap = serviceList.reduce((serviceMap, serviceDef) => {
                serviceMap[serviceDef.name] = {
                    url: serviceDef.url,
                    dataSource: this.createDataSource(serviceDef),
                };
                return serviceMap;
            }, Object.create(null));
            try {
                await this.serviceHealthCheck(serviceMap);
            }
            catch (e) {
                throw new Error('The gateway did not update its schema due to failed service health checks. ' +
                    'The gateway will continue to operate with the previous schema and reattempt updates. ' +
                    'The following error occurred during the health check:\n' +
                    e.message);
            }
        }
    }
    serviceHealthCheck(serviceMap = this.serviceMap) {
        return Promise.all(Object.entries(serviceMap).map(([name, { dataSource }]) => dataSource
            .process({
            kind: types_1.GraphQLDataSourceRequestKind.HEALTH_CHECK,
            request: { query: exports.HEALTH_CHECK_QUERY },
            context: {},
        })
            .then((response) => ({ name, response }))
            .catch((e) => {
            throw new Error(`[${name}]: ${e.message}`);
        })));
    }
    createSchemaFromServiceList(serviceList) {
        this.logger.debug(`Composing schema from service list: \n${serviceList
            .map(({ name, url }) => `  ${url || 'local'}: ${name}`)
            .join('\n')}`);
        const compositionResult = federation_1.composeAndValidate(serviceList);
        if (federation_1.compositionHasErrors(compositionResult)) {
            const { errors } = compositionResult;
            if (this.experimental_didFailComposition) {
                this.experimental_didFailComposition({
                    errors,
                    serviceList,
                    ...(this.compositionMetadata && {
                        compositionMetadata: this.compositionMetadata,
                    }),
                });
            }
            throw Error("A valid schema couldn't be composed. The following composition errors were found:\n" +
                errors.map((e) => '\t' + e.message).join('\n'));
        }
        else {
            const { supergraphSdl } = compositionResult;
            this.createServices(serviceList);
            const schema = query_planner_2.buildComposedSchema(graphql_1.parse(supergraphSdl));
            this.logger.debug('Schema loaded and ready for execution');
            return {
                schema: wrapSchemaWithAliasResolver(schema),
                supergraphSdl,
            };
        }
    }
    serviceListFromSupergraphSdl(supergraphSdl) {
        const schema = query_planner_2.buildComposedSchema(supergraphSdl);
        return this.serviceListFromComposedSchema(schema);
    }
    serviceListFromComposedSchema(schema) {
        var _a, _b;
        const graphMap = (_b = (_a = schema.extensions) === null || _a === void 0 ? void 0 : _a.federation) === null || _b === void 0 ? void 0 : _b.graphs;
        if (!graphMap) {
            throw Error(`Couldn't find graph map in composed schema`);
        }
        return Array.from(graphMap.values());
    }
    createSchemaFromSupergraphSdl(supergraphSdl) {
        this.parsedSupergraphSdl = graphql_1.parse(supergraphSdl);
        const schema = query_planner_2.buildComposedSchema(this.parsedSupergraphSdl);
        const serviceList = this.serviceListFromComposedSchema(schema);
        this.createServices(serviceList);
        return {
            schema: wrapSchemaWithAliasResolver(schema),
            supergraphSdl,
        };
    }
    onSchemaChange(callback) {
        this.onSchemaChangeListeners.add(callback);
        return () => {
            this.onSchemaChangeListeners.delete(callback);
        };
    }
    onSchemaLoadOrUpdate(callback) {
        this.onSchemaLoadOrUpdateListeners.add(callback);
        return () => {
            this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
    }
    async pollServices(unrefTimer) {
        switch (this.state.phase) {
            case 'stopping':
            case 'stopped':
            case 'failed to load':
                return;
            case 'initialized':
                throw Error('pollServices should not be called before load!');
            case 'polling':
                throw Error('pollServices should not be called while in the middle of polling!');
            case 'waiting to poll':
                throw Error('pollServices should not be called while already waiting to poll!');
            case 'loaded':
                break;
            default:
                throw new UnreachableCaseError(this.state);
        }
        await new Promise((doneWaiting) => {
            this.state = {
                phase: 'waiting to poll',
                doneWaiting,
                pollWaitTimer: setTimeout(() => {
                    if (this.state.phase == 'waiting to poll') {
                        this.state.doneWaiting();
                    }
                }, this.experimental_pollInterval || 10000),
            };
            if (unrefTimer) {
                this.state.pollWaitTimer.unref();
            }
        });
        if (this.state.phase !== 'waiting to poll') {
            return;
        }
        let pollingDone;
        this.state = {
            phase: 'polling',
            pollingDonePromise: new Promise((res) => {
                pollingDone = res;
            }),
        };
        try {
            await this.updateSchema();
        }
        catch (err) {
            this.logger.error((err && err.message) || err);
        }
        if (this.state.phase === 'polling') {
            this.state = { phase: 'loaded' };
            setImmediate(() => this.pollServices(unrefTimer));
        }
        pollingDone();
    }
    createAndCacheDataSource(serviceDef) {
        if (this.serviceMap[serviceDef.name] &&
            serviceDef.url === this.serviceMap[serviceDef.name].url)
            return this.serviceMap[serviceDef.name].dataSource;
        const dataSource = this.createDataSource(serviceDef);
        this.serviceMap[serviceDef.name] = { url: serviceDef.url, dataSource };
        return dataSource;
    }
    createDataSource(serviceDef) {
        if (!serviceDef.url && !config_1.isLocalConfig(this.config)) {
            this.logger.error(`Service definition for service ${serviceDef.name} is missing a url`);
        }
        return this.config.buildService
            ? this.config.buildService(serviceDef)
            : new RemoteGraphQLDataSource_1.RemoteGraphQLDataSource({
                url: serviceDef.url,
            });
    }
    createServices(services) {
        for (const serviceDef of services) {
            this.createAndCacheDataSource(serviceDef);
        }
    }
    async loadServiceDefinitions(config) {
        var _a, _b;
        if (config_1.isRemoteConfig(config)) {
            const serviceList = config.serviceList.map((serviceDefinition) => ({
                ...serviceDefinition,
                dataSource: this.createAndCacheDataSource(serviceDefinition),
            }));
            return loadServicesFromRemoteEndpoint_1.getServiceDefinitionsFromRemoteEndpoint({
                serviceList,
                async getServiceIntrospectionHeaders(service) {
                    return typeof config.introspectionHeaders === 'function'
                        ? await config.introspectionHeaders(service)
                        : config.introspectionHeaders;
                },
                serviceSdlCache: this.serviceSdlCache,
            });
        }
        const canUseManagedConfig = ((_a = this.apolloConfig) === null || _a === void 0 ? void 0 : _a.graphRef) && ((_b = this.apolloConfig) === null || _b === void 0 ? void 0 : _b.keyHash);
        if (!canUseManagedConfig) {
            throw new Error('When a manual configuration is not provided, gateway requires an Apollo ' +
                'configuration. See https://www.apollographql.com/docs/apollo-server/federation/managed-federation/ ' +
                'for more information. Manual configuration options include: ' +
                '`serviceList`, `supergraphSdl`, and `experimental_updateServiceDefinitions`.');
        }
        if (config_1.isPrecomposedManagedConfig(config)) {
            return loadSupergraphSdlFromStorage_1.loadSupergraphSdlFromStorage({
                graphRef: this.apolloConfig.graphRef,
                apiKey: this.apolloConfig.key,
                endpoint: this.schemaConfigDeliveryEndpoint,
                fetcher: this.fetcher,
            });
        }
        else if (config_1.isLegacyManagedConfig(config)) {
            return legacyLoadServicesFromStorage_1.getServiceDefinitionsFromStorage({
                graphRef: this.apolloConfig.graphRef,
                apiKeyHash: this.apolloConfig.keyHash,
                federationVersion: config.federationVersion || 1,
                fetcher: this.fetcher,
            });
        }
        else {
            throw new Error('Programming error: unhandled configuration');
        }
    }
    maybeWarnOnConflictingConfig() {
        var _a, _b;
        const canUseManagedConfig = ((_a = this.apolloConfig) === null || _a === void 0 ? void 0 : _a.graphRef) && ((_b = this.apolloConfig) === null || _b === void 0 ? void 0 : _b.keyHash);
        if (!config_1.isManagedConfig(this.config) &&
            canUseManagedConfig &&
            !this.warnedStates.remoteWithLocalConfig) {
            this.warnedStates.remoteWithLocalConfig = true;
            this.logger.warn('A local gateway configuration is overriding a managed federation ' +
                'configuration.  To use the managed ' +
                'configuration, do not specify a service list or supergraphSdl locally.');
        }
    }
    validateIncomingRequest(requestContext, operationContext) {
        return opentelemetry_1.tracer.startActiveSpan(opentelemetry_1.OpenTelemetrySpanNames.VALIDATE, (span) => {
            try {
                const variableDefinitions = operationContext.operation
                    .variableDefinitions;
                if (!variableDefinitions)
                    return [];
                const { errors } = values_1.getVariableValues(operationContext.schema, variableDefinitions, requestContext.request.variables || {});
                if (errors) {
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                }
                return errors || [];
            }
            catch (err) {
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    async stop() {
        switch (this.state.phase) {
            case 'initialized':
            case 'failed to load':
                throw Error('ApolloGateway.stop does not need to be called before ApolloGateway.load is called successfully');
            case 'stopped':
                return;
            case 'stopping':
                await this.state.stoppingDonePromise;
                if (this.state.phase !== 'stopped') {
                    throw Error(`Expected to be stopped when done stopping, but instead ${this.state.phase}`);
                }
                return;
            case 'loaded':
                this.state = { phase: 'stopped' };
                return;
            case 'waiting to poll': {
                const doneWaiting = this.state.doneWaiting;
                clearTimeout(this.state.pollWaitTimer);
                this.state = { phase: 'stopped' };
                doneWaiting();
                return;
            }
            case 'polling': {
                const pollingDonePromise = this.state.pollingDonePromise;
                let stoppingDone;
                this.state = {
                    phase: 'stopping',
                    stoppingDonePromise: new Promise((res) => {
                        stoppingDone = res;
                    }),
                };
                await pollingDonePromise;
                this.state = { phase: 'stopped' };
                stoppingDone();
                return;
            }
            default:
                throw new UnreachableCaseError(this.state);
        }
    }
}
exports.ApolloGateway = ApolloGateway;
function approximateObjectSize(obj) {
    return Buffer.byteLength(JSON.stringify(obj), 'utf8');
}
function wrapSchemaWithAliasResolver(schema) {
    const typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach((typeName) => {
        const type = typeMap[typeName];
        if (graphql_1.isObjectType(type) && !graphql_1.isIntrospectionType(type)) {
            const fields = type.getFields();
            Object.keys(fields).forEach((fieldName) => {
                const field = fields[fieldName];
                field.resolve = executeQueryPlan_1.defaultFieldResolverWithAliasSupport;
            });
        }
    });
    return schema;
}
class UnreachableCaseError extends Error {
    constructor(val) {
        super(`Unreachable case: ${val}`);
    }
}
__exportStar(require("./datasources"), exports);
//# sourceMappingURL=index.js.map