/// <reference path="../src/make-fetch-happen.d.ts" />
import { GraphQLService, Unsubscriber } from 'apollo-server-core';
import { GraphQLExecutionResult, GraphQLRequestContextExecutionDidStart } from 'apollo-server-types';
import { GraphQLSchema } from 'graphql';
import { buildOperationContext } from './operationContext';
import { executeQueryPlan, ServiceMap } from './executeQueryPlan';
import { GraphQLDataSource } from './datasources/types';
import { ServiceEndpointDefinition, Experimental_DidFailCompositionCallback, Experimental_DidResolveQueryPlanCallback, Experimental_DidUpdateCompositionCallback, Experimental_UpdateComposition, CompositionInfo, GatewayConfig, RemoteGatewayConfig, ManagedGatewayConfig, CompositionUpdate } from './config';
declare type DataSourceMap = {
    [serviceName: string]: {
        url?: string;
        dataSource: GraphQLDataSource;
    };
};
export declare function getDefaultFetcher(): import("make-fetch-happen").Fetcher & {
    defaults(opts?: (import("apollo-server-env").RequestInit & import("make-fetch-happen").FetcherOptions) | undefined): import("make-fetch-happen").Fetcher & any;
};
export declare const getDefaultGcsFetcher: typeof getDefaultFetcher;
export declare const GCS_RETRY_COUNT = 5;
export declare const HEALTH_CHECK_QUERY = "query __ApolloServiceHealthCheck__ { __typename }";
export declare const SERVICE_DEFINITION_QUERY = "query __ApolloGetServiceDefinition__ { _service { sdl } }";
interface ApolloConfigFromAS2Or3 {
    key?: string;
    keyHash?: string;
    graphRef?: string;
    graphId?: string;
    graphVariant?: string;
}
interface GraphQLServiceEngineConfig {
    apiKeyHash: string;
    graphId: string;
    graphVariant?: string;
}
export declare class ApolloGateway implements GraphQLService {
    schema?: GraphQLSchema;
    private serviceMap;
    private config;
    private logger;
    private queryPlanStore;
    private apolloConfig?;
    private onSchemaChangeListeners;
    private onSchemaLoadOrUpdateListeners;
    private serviceDefinitions;
    private compositionMetadata?;
    private serviceSdlCache;
    private warnedStates;
    private queryPlanner?;
    private parsedSupergraphSdl?;
    private fetcher;
    private compositionId?;
    private state;
    private experimental_didResolveQueryPlan?;
    private experimental_didFailComposition?;
    private experimental_didUpdateComposition?;
    private updateServiceDefinitions;
    private experimental_pollInterval?;
    private schemaConfigDeliveryEndpoint?;
    constructor(config?: GatewayConfig);
    private initLogger;
    private initQueryPlanStore;
    private issueDynamicWarningsIfApplicable;
    load(options?: {
        apollo?: ApolloConfigFromAS2Or3;
        engine?: GraphQLServiceEngineConfig;
    }): Promise<{
        schema: GraphQLSchema;
        executor: <TContext>(requestContext: GraphQLRequestContextExecutionDidStart<TContext>) => Promise<GraphQLExecutionResult>;
    }>;
    private loadStatic;
    private loadDynamic;
    private shouldBeginPolling;
    private updateSchema;
    private updateByComposition;
    private updateWithSupergraphSdl;
    private updateWithSchemaAndNotify;
    private maybePerformServiceHealthCheck;
    serviceHealthCheck(serviceMap?: DataSourceMap): Promise<{
        name: string;
        response: import("apollo-server-types").GraphQLResponse;
    }[]>;
    private createSchemaFromServiceList;
    private serviceListFromSupergraphSdl;
    private serviceListFromComposedSchema;
    private createSchemaFromSupergraphSdl;
    onSchemaChange(callback: (schema: GraphQLSchema) => void): Unsubscriber;
    onSchemaLoadOrUpdate(callback: (schemaContext: {
        apiSchema: GraphQLSchema;
        coreSupergraphSdl: string;
    }) => void): Unsubscriber;
    private pollServices;
    private createAndCacheDataSource;
    private createDataSource;
    private createServices;
    protected loadServiceDefinitions(config: RemoteGatewayConfig | ManagedGatewayConfig): Promise<CompositionUpdate>;
    private maybeWarnOnConflictingConfig;
    executor: <TContext>(requestContext: GraphQLRequestContextExecutionDidStart<TContext>) => Promise<GraphQLExecutionResult>;
    private validateIncomingRequest;
    stop(): Promise<void>;
}
export { executeQueryPlan, buildOperationContext, ServiceMap, Experimental_DidFailCompositionCallback, Experimental_DidResolveQueryPlanCallback, Experimental_DidUpdateCompositionCallback, Experimental_UpdateComposition, GatewayConfig, ServiceEndpointDefinition, CompositionInfo, };
export * from './datasources';
//# sourceMappingURL=index.d.ts.map